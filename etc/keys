#!/usr/bin/env bash

require 'rayvn/core' 'rayvn/safe-source' 'valt/age' 'valt/password'

usage() {
    echo
    echo "$(ansi bold Generate an age public key pair and backup documentation)."
    echo
    echo "Usage: $(ansi bold_blue valt keys) [OPTIONS]"
    echo
    echo "Private keys are encrypted and a strong passphrase is $(ansi bold_green highly) encouraged; advice and an opportunity to"
    echo "generate one will be offered."
    echo
    echo "A PDF file will be created containing your keys, also in encrypted form, to serve as a backup for you and/or your"
    echo "successors. Detailed usage instructions are included. Keys are represented as a QR code and again in a text format"
    echo "(often called \"paper keys\"). Content will be personalized: you will be prompted to edit a $(ansi blue key.info) file".
    echo
    echo "By default, the passphrase you enter when creating the keys will be included in the generated PDF and you will be"
    echo "prompted to select a printer and choose a copy count. After printing, the PDF will be deleted to keep your passphrase"
    echo "secure."
    echo
    echo "   $(ansi bold store the documents in secure locations, e.g. safe deposit box/fire safe and/or with trusted people!)"
    echo
    echo "If you specify the --no-passphrase option, you will not be prompted to the print the PDF. However, you $(ansi bold must) still"
    echo "make the passphrase available to whomever has access to the document! To ensure this, the 'notes' property in the"
    echo "$(ansi blue key.info) will be required and should be used to help guide the reader to access the passphrase."
    echo
    echo "Options"
    echo
    echo "    -p, --prefix PREFIX           Use PREFIX for key file names. Defaults to ${USER}."
    echo "    -f, --force                   Overwrite existing files."
    echo "    --no-verify                   Do not verify keys."
    echo "    --no-advice                   Do not show passphrase advice."
    echo "    --no-pdf                      Do not generate PDF file."
    echo "    --no-passphrase               Do not include the passphrase on the PDF file."
    echo "    -q, --quick                   Do not verify keys or show passphrase advice."
    echo "    -t, --template TEMPLATE       Use the TEMPLATE markdown file instead of the default for PDF generation."
    echo "    -c, --css CSS                 Apply style overrides from the CSS file for PDF generation."
    echo "    -h, --help                    Display usage and exit."
    echo
    echo "$(ansi bold Document Customization)"
    echo
    echo "The HTML template can be changed from the default and CSS style overrides can be applied. The default template"
    echo "and primary CSS file can be found in the $(ansi blue ${valtEtcDir}) directory."
    echo
    echo "Template substitutions are performed with variables defined in the $(ansi blue key.info) file. Note that keys"
    echo "prefixed with an underscore are reserved for system use."
    echo
    echo "The template can be specified with the --template option, and default styles can be extended using the --css option."
    bye
}

main() {
    init "${@}"
    createKeys
    if (( generatePdf )); then
        createKeyDocument
    fi
    echo
}

init() {
    declare -gr keyInfoTemplateFile="${valtEtcDir}/key-info-template.sh"
    declare -gr keyInfoFile="${valtConfigDir}/key.info"
    declare -gr cssMainFileName="key-doc.css"
    declare -gr logoFileName="phoggy.png"
    declare -gr assetFiles=("${cssMainFileName}" "${logoFileName}")
    declare -gr cssOverrideFileName='override.css'
    declare -gr htmlFileName='note.html'
    declare -gr qrCodeFileName='qr.png'
    qrCodeFile=
    armoredKey=
    defaultPrinter=

    # Options
    htmlTemplateFile="${valtEtcDir}/key-doc-template.html"
    cssOverrideFile=
    htmlFile=
    prefix="${USER}"
    htmlFile=

    # Flags
    declare -gi force=0
    declare -gi verifyKeys=1
    declare -gi showKeyAdvice=1
    declare -gi generatePdf=1
    declare -gi includePassphrase=1
    declare -gi printPdf=1
    declare -gi deletePdfAfterPrint=1

    while (( ${#} > 0 )); do
        case "${1}" in
            --) ;;
            -p | --prefix) shift; setPrefix "${1}";;
            -t | --template) shift; setFileVar templateFile "${1}" "TEMPLATE" ;;
            -c | --css) shift; setFileVar cssOverrideFile "${1}" "CSS" ;;
            --no-verify) verifyKeys=0 ;;
            --no-advice) showKeyAdvice=0 ;;
            --no-pdf) generatePdf=0; includePassphrase=0; printPdf=0; deletePdfAfterPrint=0 ;;
            --no-passphrase) includePassphrase=0; printPdf=0; deletePdfAfterPrint=0 ;;
            -q | --quick) showKeyAdvice=0; verifyKeys=0 ;;
            -f | --force) force=1 ;;
            -h | --help | help) usage ;;
            -*) usage "Unknown option: ${1}" ;;
        esac
        shift
    done

    privateKeyFile="${valtConfigDir}/${prefix}.key"
    publicKeyFile="${valtConfigDir}/${prefix}-public.key"

    if (( force )); then
        rm "${publicKeyFile}" "${privateKeyFile}" 2> /dev/null
    else
        assertFileDoesNotExist "${privateKeyFile}"
        assertFileDoesNotExist "${publicKeyFile}"
    fi

    prepareForPdf
}

prepareForPdf() {
    if (( generatePdf )); then
        ensureKeyInfo
        require 'valt/pdf'
        documentsFile="${valtConfigDir}/${prefix}-key.pdf"

        if (( printPdf )); then
            local printers status prompt answer
            local printers="$(system_profiler SPPrintersDataType -json)"
            defaultPrinter="$(echo "${printers}" | jq -r '.SPPrintersDataType[] | select(.default == "yes") | ._name')"
            status="$(echo "${printers}" | jq -r --arg name "${defaultPrinter}" '.SPPrintersDataType[] | select(._name == $name) | .status')"
            echo
            if [[ ${status} == offline ]]; then
                echo "Your default printer '${defaultPrinter}' is $(ansi bold_red offline)."
                echo "If you just powered on, it may take up to a minute before it appears online."
                read -p "Continue without printing key documentation? $(ansi dim [y/n]) " answer
                [[ ${answer} == y ]] || exit 0
                printPdf=0
                includePassphrase=0
            else
                echo "Key documentation will be printed to your default printer '${defaultPrinter}'."
                if (( includePassphrase )); then
                    echo "The passphrase that you enter below will be included in the document."
                    if (( deletePdfAfterPrint )); then
                        echo "After printing, the document will be deleted for your security."
                    fi
                fi
            fi
        fi
    fi
}

setPrefix() {
    assertValidFileName "${1}"
    prefix="${1}"
}

ensureKeyInfo() {
    local status="has not been"

    if [[ ! -f "${keyInfoFile}" ]]; then
        cp "${keyInfoTemplateFile}" "${keyInfoFile}" || fail
        status="must be"
    else
        sourceSafeStaticVars "${keyInfoFile}"
        assertKeyInfoVar closing author completed
        assertKeyInfoArrayVar contacts
        (( includePassphrase )) || assertKeyInfoArrayVar notes # required if passphrase omitted

        if [[ ${completed} == yes ]]; then
            return 0
        fi
    fi

    echo
    echo "The $(ansi bold key.info) file at $(ansi blue ${valtConfigDir}) ${status} completed."
    echo "Please edit and complete it before proceeding."
    bye
}

assertKeyInfoVar() {
    while (( ${#} > 0 )); do
        local varName="${1}"
        [[ -v ${varName} ]] || bye "The '${varName}' variable is missing in ${keyInfoFile}."
        [[ -n ${!varName} ]] || bye "The '${varName}' variable cannot be empty in ${keyInfoFile}."
        shift
    done
}

assertKeyInfoArrayVar() {
    local name="${1}"

    declare -p "${name}" &> /dev/null || bye "The '${name}' array variable is missing in ${keyInfoFile}."

    if ! declare -p "${name}" 2> /dev/null | grep -q '^declare \-a'; then
        bye "The '${name}' variable must be an array in ${keyInfoFile}."
    fi

    local -n nameRef="${name}"
    (( ${#nameRef[@]} > 0 )) || bye "The '${name}' array variable cannot be empty in ${keyInfoFile}."
}


createKeys() {
    echo
    echo "$(ansi bold Generating keys)"
    if (( showKeyAdvice )); then
        echo
        showAgeKeyPairAdvice
        local reply
        read -t ${inputTimeout} -p "Would you like help generating a passphrase? (y/n): " reply
        echo
        [[ ${reply,,} == 'y' ]] && generatePass
    fi
    if (( includePassphrase )); then
        createAgeKeyPair "${privateKeyFile}" "${publicKeyFile}" _PHRASE || fail
    else
        createAgeKeyPair "${privateKeyFile}" "${publicKeyFile}" || fail
        _PHRASE="(see Notes)"
    fi
    echo
    echo "Public key (aka 'recipient') file: $(ansi cyan ${publicKeyFile})"
    echo "Private key (aka 'identity') file: $(ansi cyan ${privateKeyFile}) (also contains public key)"

    if (( verifyKeys )); then
        echo
        echo "$(ansi bold Verifying keys)"
        echo
        verifyAgeKeyPair "${privateKeyFile}" "${publicKeyFile}"
        echo
        echo "$(ansi bold_green Verified) that a file encrypted with $(ansi cyan ${publicKeyFile}) decrypts with passphrase and $(ansi cyan ${privateKeyFile})."
    fi
}

generatePass() {
    echo "$(ansi bold_yellow TODO): implement generatePass()!" # TODO!!
    echo
}

createKeyDocument() {
    local options=
    echo
    echo "$(ansi bold Generating documentation)"
    echo
    createPdf
    echo
    echo "Keys documented in $(ansi cyan ${documentsFile})"
    open "${documentsFile}" &> /dev/null
}

createPdf() {
# TODO!    local workDir=$(tempDirPath)
    local workDir="${PWD}"
    local footerTemplate

    # Set armoredKey var

    armorAgeFile "${privateKeyFile}" armoredKey

    # Copy asset files

    for assetFile in "${assetFiles[@]}"; do
        cp "${valtEtcDir}/${assetFile}" "${workDir}/${assetFile}" || fail
    done

    if [[ ${cssOverrideFile} ]]; then
        cp "${cssOverrideFile}" "${workDir}/${cssOverrideFileName}" || fail
    fi

    # Create QR code

    qrCodeFile="${workDir}/${qrCodeFileName}"
    echo "${armoredKey}" | qrencode -l H -o "${qrCodeFile}" || fail
    assertFileExists "${qrCodeFile}"

    # Generate substituted html file and footer template

    htmlFile="${workDir}/${htmlFileName}"
    generateHtml "${htmlFile}"
    assertFileExists "${htmlFile}"
    footerTemplate="$(generateFooterTemplate)"

    # Move to work dir so that relative paths in html work correctly and
    # generate the pdf

    cd ${workDir} || fail
    generatePdf "${htmlFile}" "${documentsFile}" "${footerTemplate}" || fail

    # Set metadata and encrypt with a strong password

    local title='Private Key Pair Backup & Usage Instructions'
    local creator="$(projectVersion valt), ${valtProjectUrl}"
    local subject="File decryption."
    local keywords="${author}, valt, private key, backup, encryption, decryption, security"

    exiftool \
        -Title="${title}" \
        -Author="${author}" \
        -Subject="${subject}" \
        -Keywords="${keywords}" \
        -Creator="${creator}" \
        -overwrite_original \
        "${documentsFile}"  > /dev/null || fail

    # Encrypt with a strong owner password so that permissions cannot be changed, ensuring
    # that the user password is empty so viewing does not require a password. The owner
    # password should never be required. Note that if we ever want actual form fields,
    # the --modify option must be changed to allow filling.

    local ownerPW="$(phraze)"
    local userPW=''

    qpdf ${documentsFile} \
        --encrypt "${userPW}" "${ownerPW}" 256 --modify=none -- \
        --replace-input  || fail
}

generateFooterTemplate() {
    local footerClass=$(awk '
        /^[[:space:]]*\.footer[[:space:]]*\{/ {
            print
            brace_count = 1
            while ((getline line) > 0) {
                print line
                # Count opening and closing braces
                temp1 = line
                gsub(/[^{]/, "", temp1)
                opening = length(temp1)
                temp2 = line
                gsub(/[^}]/, "", temp2)
                closing = length(temp2)
                brace_count += opening - closing
                if (brace_count == 0) break
            }
            exit
        }
        ' "${valtEtcDir}/key-doc.css")

    cat <<- EOF
		<style>
		    ${footerClass}
		    .page-info .pageNumber::after {
		        content: " / ";
		    }
		</style>
		<div class="footer">
		    <span>${author} Private Key</span>
		    <span>$(date '+%B %e, %Y')</span>
		    <span class="page-info"><span class="pageNumber"></span><span class="totalPages"></span></span>
		</div>
	EOF
}

generateHtml() {
    local outputFile="${1}"
    local html="$(< ${htmlTemplateFile})" || fail
    local contact note value

    # Set built-in substitution values (clobbering any that the user might have defined)

    local _GREETING="${greeting}"
    local _DATE="$(date "+%B %d, %Y %r %Z")"
    local _CSS_PATH="${cssMainFileName}"
    local _LOGO_PATH="${logoFileName}"
    local _QR_CODE_PATH="${qrCodeFileName}"
    local _ARMORED_KEY="${armoredKey}"
    local _CSS_OVERRIDE='<!-- placeholder -->'
    if [[ ${cssOverrideFile} ]]; then
        _CSS_OVERRIDE="<link rel="stylesheet" href="${cssOverrideFileName}">"
    fi

    local _PASSPHRASE_LOCATION
    if (( includePassphrase )); then
        _PASSPHRASE_LOCATION="The last page includes the passphrase."
    else
        _PASSPHRASE_LOCATION="The last page contains notes that should provide some information to help find the passphrase.\
                                 If you <em>don't have or can't get the passphrase</em>, stop here. Yes, really (sorry!)."
    fi

    # Transform contacts into list items

    local _CONTACTS_LIST=
    for contact in "${contacts[@]}"; do
        _CONTACTS_LIST+="<li>${contact}</li>"
    done

    # Transform notes into paragraphs

    local _NOTES=
    for note in "${notes[@]}"; do
        _NOTES+="<p>${note}</p>"
    done

    # Collect all required substitution keys (consumes tempHtml)

    local tempHtml="${html}"
    local requiredSubstitutionKeys=()

    while [[ ${tempHtml} =~ ([^{]*)\}(.*) ]]; do
        requiredSubstitutionKeys+=("${BASH_REMATCH[1]}")
        tempHtml="${BASH_REMATCH[2]}"
    done

    # Perform the substitutions, failing if a required substitution is not defined

    for key in "${requiredSubstitutionKeys[@]}"; do
        value="${!key}"
        [[ -v key ]] || fail "${key} not set in ${keyInfoFile}"
        [[ -n "${value}" ]] || fail "${key} value not set in ${keyInfoFile}"
        html=${html/\$\{${key}\}/${value}}
    done
    echo "${html}" > "${outputFile}"
}

main "${@}"
